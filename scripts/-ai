#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Parse options
accept_edits=false
branch_name=""
base=""

while getopts "an:b:" opt; do
  case "$opt" in
    a) accept_edits=true ;;
    n) branch_name="$OPTARG" ;;
    b) base="$OPTARG" ;;
    *) echo "Usage: -ai [-a] [-n branch_name] [-b base]" >&2; exit 1 ;;
  esac
done
shift $((OPTIND - 1))

# Build adapter args
adapter_args=()
if [[ "$accept_edits" == true ]]; then
  adapter_args+=("--permission-mode" "acceptEdits")
fi

# Create prompt file with timestamp and tag
mkdir -p ~/ai-prompts
folder_name="$(basename "$(pwd)")"
if [[ -n "$branch_name" ]]; then
  tag="${folder_name}_${branch_name}"
else
  tag="$folder_name"
fi
prompt_file=~/ai-prompts/"$(date '+%Y-%m-%d_%H-%M-%S')_${tag}.md"
"${EDITOR:-vim}" "$prompt_file"

# Handle worktree
if [[ -n "$branch_name" ]]; then
  worktree_path="$(-git-worktrees-dir)/$branch_name"

  if [[ -d "$worktree_path" ]]; then
    cd "$worktree_path"
  else
    if [[ -z "$base" ]]; then
      base_ref=""
      for remote in $(git remote); do
        for branch in main master; do
          if git ls-remote --exit-code --heads "$remote" "$branch" >/dev/null 2>&1; then
            base_ref="$remote/$branch"
            break 2
          fi
        done
      done
      if [[ -z "$base_ref" ]]; then
        echo "error: could not find main or master on any remote" >&2
        exit 1
      fi
      git fetch "${base_ref%%/*}" "${base_ref##*/}" --prune
      base="$base_ref"
    fi
    mkdir -p "$(dirname "$worktree_path")"
    if git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
      git worktree add "$worktree_path" "$branch_name"
    else
      git worktree add -b "$branch_name" "$worktree_path" "$base"
    fi
    cd "$worktree_path"
  fi
fi

# Run adapter: pipe file content if non-empty, otherwise just call
if grep -q '[^[:space:]]' "$prompt_file" 2>/dev/null; then
  cat "$prompt_file" | -ai-agent-adapter "${adapter_args[@]}" "$@"
else
  -ai-agent-adapter "${adapter_args[@]}" "$@"
fi
